// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package data

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

type TickT struct {
	EpochLocalTime int64 `json:"epoch_local_time"`
	Symbol string `json:"symbol"`
	Market string `json:"market"`
	StreamId uint32 `json:"stream_id"`
	EpochExchgTime int64 `json:"epoch_exchg_time"`
	Channel uint16 `json:"channel"`
	Status int32 `json:"status"`
	PreClose float64 `json:"pre_close"`
	Open float64 `json:"open"`
	High float64 `json:"high"`
	Low float64 `json:"low"`
	Match float64 `json:"match"`
	Close float64 `json:"close"`
	AskPx []float64 `json:"ask_px"`
	BidPx []float64 `json:"bid_px"`
	AskVol []int64 `json:"ask_vol"`
	BidVol []int64 `json:"bid_vol"`
	UpperLimit float64 `json:"upper_limit"`
	LowerLimit float64 `json:"lower_limit"`
	Volume uint64 `json:"volume"`
	Amount float64 `json:"amount"`
	SettlePx float64 `json:"settle_px"`
	PreSettlePx float64 `json:"pre_settle_px"`
	Interest int64 `json:"interest"`
	PreInterest int64 `json:"pre_interest"`
	NumTrades int32 `json:"num_trades"`
	TotalBidVol int64 `json:"total_bid_vol"`
	TotalAskVol int64 `json:"total_ask_vol"`
	WeightedAvgBidPx float64 `json:"weighted_avg_bid_px"`
	WeightedAvgAskPx float64 `json:"weighted_avg_ask_px"`
	LocalTime uint32 `json:"local_time"`
	ExchgTime uint32 `json:"exchg_time"`
	TradeDate int64 `json:"trade_date"`
	Key int32 `json:"key"`
	EamCode int64 `json:"eam_code"`
}

func (t *TickT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	symbolOffset := flatbuffers.UOffsetT(0)
	if t.Symbol != "" {
		symbolOffset = builder.CreateString(t.Symbol)
	}
	marketOffset := flatbuffers.UOffsetT(0)
	if t.Market != "" {
		marketOffset = builder.CreateString(t.Market)
	}
	askPxOffset := flatbuffers.UOffsetT(0)
	if t.AskPx != nil {
		askPxLength := len(t.AskPx)
		TickStartAskPxVector(builder, askPxLength)
		for j := askPxLength - 1; j >= 0; j-- {
			builder.PrependFloat64(t.AskPx[j])
		}
		askPxOffset = builder.EndVector(askPxLength)
	}
	bidPxOffset := flatbuffers.UOffsetT(0)
	if t.BidPx != nil {
		bidPxLength := len(t.BidPx)
		TickStartBidPxVector(builder, bidPxLength)
		for j := bidPxLength - 1; j >= 0; j-- {
			builder.PrependFloat64(t.BidPx[j])
		}
		bidPxOffset = builder.EndVector(bidPxLength)
	}
	askVolOffset := flatbuffers.UOffsetT(0)
	if t.AskVol != nil {
		askVolLength := len(t.AskVol)
		TickStartAskVolVector(builder, askVolLength)
		for j := askVolLength - 1; j >= 0; j-- {
			builder.PrependInt64(t.AskVol[j])
		}
		askVolOffset = builder.EndVector(askVolLength)
	}
	bidVolOffset := flatbuffers.UOffsetT(0)
	if t.BidVol != nil {
		bidVolLength := len(t.BidVol)
		TickStartBidVolVector(builder, bidVolLength)
		for j := bidVolLength - 1; j >= 0; j-- {
			builder.PrependInt64(t.BidVol[j])
		}
		bidVolOffset = builder.EndVector(bidVolLength)
	}
	TickStart(builder)
	TickAddEpochLocalTime(builder, t.EpochLocalTime)
	TickAddSymbol(builder, symbolOffset)
	TickAddMarket(builder, marketOffset)
	TickAddStreamId(builder, t.StreamId)
	TickAddEpochExchgTime(builder, t.EpochExchgTime)
	TickAddChannel(builder, t.Channel)
	TickAddStatus(builder, t.Status)
	TickAddPreClose(builder, t.PreClose)
	TickAddOpen(builder, t.Open)
	TickAddHigh(builder, t.High)
	TickAddLow(builder, t.Low)
	TickAddMatch(builder, t.Match)
	TickAddClose(builder, t.Close)
	TickAddAskPx(builder, askPxOffset)
	TickAddBidPx(builder, bidPxOffset)
	TickAddAskVol(builder, askVolOffset)
	TickAddBidVol(builder, bidVolOffset)
	TickAddUpperLimit(builder, t.UpperLimit)
	TickAddLowerLimit(builder, t.LowerLimit)
	TickAddVolume(builder, t.Volume)
	TickAddAmount(builder, t.Amount)
	TickAddSettlePx(builder, t.SettlePx)
	TickAddPreSettlePx(builder, t.PreSettlePx)
	TickAddInterest(builder, t.Interest)
	TickAddPreInterest(builder, t.PreInterest)
	TickAddNumTrades(builder, t.NumTrades)
	TickAddTotalBidVol(builder, t.TotalBidVol)
	TickAddTotalAskVol(builder, t.TotalAskVol)
	TickAddWeightedAvgBidPx(builder, t.WeightedAvgBidPx)
	TickAddWeightedAvgAskPx(builder, t.WeightedAvgAskPx)
	TickAddLocalTime(builder, t.LocalTime)
	TickAddExchgTime(builder, t.ExchgTime)
	TickAddTradeDate(builder, t.TradeDate)
	TickAddKey(builder, t.Key)
	TickAddEamCode(builder, t.EamCode)
	return TickEnd(builder)
}

func (rcv *Tick) UnPackTo(t *TickT) {
	t.EpochLocalTime = rcv.EpochLocalTime()
	t.Symbol = string(rcv.Symbol())
	t.Market = string(rcv.Market())
	t.StreamId = rcv.StreamId()
	t.EpochExchgTime = rcv.EpochExchgTime()
	t.Channel = rcv.Channel()
	t.Status = rcv.Status()
	t.PreClose = rcv.PreClose()
	t.Open = rcv.Open()
	t.High = rcv.High()
	t.Low = rcv.Low()
	t.Match = rcv.Match()
	t.Close = rcv.Close()
	askPxLength := rcv.AskPxLength()
	t.AskPx = make([]float64, askPxLength)
	for j := 0; j < askPxLength; j++ {
		t.AskPx[j] = rcv.AskPx(j)
	}
	bidPxLength := rcv.BidPxLength()
	t.BidPx = make([]float64, bidPxLength)
	for j := 0; j < bidPxLength; j++ {
		t.BidPx[j] = rcv.BidPx(j)
	}
	askVolLength := rcv.AskVolLength()
	t.AskVol = make([]int64, askVolLength)
	for j := 0; j < askVolLength; j++ {
		t.AskVol[j] = rcv.AskVol(j)
	}
	bidVolLength := rcv.BidVolLength()
	t.BidVol = make([]int64, bidVolLength)
	for j := 0; j < bidVolLength; j++ {
		t.BidVol[j] = rcv.BidVol(j)
	}
	t.UpperLimit = rcv.UpperLimit()
	t.LowerLimit = rcv.LowerLimit()
	t.Volume = rcv.Volume()
	t.Amount = rcv.Amount()
	t.SettlePx = rcv.SettlePx()
	t.PreSettlePx = rcv.PreSettlePx()
	t.Interest = rcv.Interest()
	t.PreInterest = rcv.PreInterest()
	t.NumTrades = rcv.NumTrades()
	t.TotalBidVol = rcv.TotalBidVol()
	t.TotalAskVol = rcv.TotalAskVol()
	t.WeightedAvgBidPx = rcv.WeightedAvgBidPx()
	t.WeightedAvgAskPx = rcv.WeightedAvgAskPx()
	t.LocalTime = rcv.LocalTime()
	t.ExchgTime = rcv.ExchgTime()
	t.TradeDate = rcv.TradeDate()
	t.Key = rcv.Key()
	t.EamCode = rcv.EamCode()
}

func (rcv *Tick) UnPack() *TickT {
	if rcv == nil {
		return nil
	}
	t := &TickT{}
	rcv.UnPackTo(t)
	return t
}

type Tick struct {
	_tab flatbuffers.Table
}

func GetRootAsTick(buf []byte, offset flatbuffers.UOffsetT) *Tick {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Tick{}
	x.Init(buf, n+offset)
	return x
}

func FinishTickBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	builder.Finish(offset)
}

func GetSizePrefixedRootAsTick(buf []byte, offset flatbuffers.UOffsetT) *Tick {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &Tick{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func FinishSizePrefixedTickBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	builder.FinishSizePrefixed(offset)
}

func (rcv *Tick) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Tick) Table() flatbuffers.Table {
	return rcv._tab
}

/// 本地接收日期时间，Epoch时间(13位数字，UTC时区)，样例：1676017139000
func (rcv *Tick) EpochLocalTime() int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetInt64(o + rcv._tab.Pos)
	}
	return 0
}

/// 本地接收日期时间，Epoch时间(13位数字，UTC时区)，样例：1676017139000
func (rcv *Tick) MutateEpochLocalTime(n int64) bool {
	return rcv._tab.MutateInt64Slot(4, n)
}

/// 证券代码
func (rcv *Tick) Symbol() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// 证券代码
///市场
///SZ,SH,HK,CF,BJ,O,N
func (rcv *Tick) Market() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

///市场
///SZ,SH,HK,CF,BJ,O,N
/// 行情类别，新增
func (rcv *Tick) StreamId() uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.GetUint32(o + rcv._tab.Pos)
	}
	return 0
}

/// 行情类别，新增
func (rcv *Tick) MutateStreamId(n uint32) bool {
	return rcv._tab.MutateUint32Slot(10, n)
}

/// 交易所行情日期时间，Epoch时间(13位数字，UTC时区)，样例：1676017139000
func (rcv *Tick) EpochExchgTime() int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.GetInt64(o + rcv._tab.Pos)
	}
	return 0
}

/// 交易所行情日期时间，Epoch时间(13位数字，UTC时区)，样例：1676017139000
func (rcv *Tick) MutateEpochExchgTime(n int64) bool {
	return rcv._tab.MutateInt64Slot(12, n)
}

/// 通道，新增
func (rcv *Tick) Channel() uint16 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.GetUint16(o + rcv._tab.Pos)
	}
	return 0
}

/// 通道，新增
func (rcv *Tick) MutateChannel(n uint16) bool {
	return rcv._tab.MutateUint16Slot(14, n)
}

/// 状态
func (rcv *Tick) Status() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

/// 状态
func (rcv *Tick) MutateStatus(n int32) bool {
	return rcv._tab.MutateInt32Slot(16, n)
}

/// 前收盘价
func (rcv *Tick) PreClose() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// 前收盘价
func (rcv *Tick) MutatePreClose(n float64) bool {
	return rcv._tab.MutateFloat64Slot(18, n)
}

/// 开盘价
func (rcv *Tick) Open() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// 开盘价
func (rcv *Tick) MutateOpen(n float64) bool {
	return rcv._tab.MutateFloat64Slot(20, n)
}

/// 最高价
func (rcv *Tick) High() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// 最高价
func (rcv *Tick) MutateHigh(n float64) bool {
	return rcv._tab.MutateFloat64Slot(22, n)
}

/// 最低价
func (rcv *Tick) Low() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(24))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// 最低价
func (rcv *Tick) MutateLow(n float64) bool {
	return rcv._tab.MutateFloat64Slot(24, n)
}

/// 最新价
func (rcv *Tick) Match() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// 最新价
func (rcv *Tick) MutateMatch(n float64) bool {
	return rcv._tab.MutateFloat64Slot(26, n)
}

/// 收盘价，新增
func (rcv *Tick) Close() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(28))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// 收盘价，新增
func (rcv *Tick) MutateClose(n float64) bool {
	return rcv._tab.MutateFloat64Slot(28, n)
}

/// 申卖价
func (rcv *Tick) AskPx(j int) float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(30))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetFloat64(a + flatbuffers.UOffsetT(j*8))
	}
	return 0
}

func (rcv *Tick) AskPxLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(30))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// 申卖价
func (rcv *Tick) MutateAskPx(j int, n float64) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(30))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateFloat64(a+flatbuffers.UOffsetT(j*8), n)
	}
	return false
}

/// 申买价
func (rcv *Tick) BidPx(j int) float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(32))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetFloat64(a + flatbuffers.UOffsetT(j*8))
	}
	return 0
}

func (rcv *Tick) BidPxLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(32))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// 申买价
func (rcv *Tick) MutateBidPx(j int, n float64) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(32))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateFloat64(a+flatbuffers.UOffsetT(j*8), n)
	}
	return false
}

/// 申卖量
func (rcv *Tick) AskVol(j int) int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(34))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetInt64(a + flatbuffers.UOffsetT(j*8))
	}
	return 0
}

func (rcv *Tick) AskVolLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(34))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// 申卖量
func (rcv *Tick) MutateAskVol(j int, n int64) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(34))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateInt64(a+flatbuffers.UOffsetT(j*8), n)
	}
	return false
}

/// 申买量
func (rcv *Tick) BidVol(j int) int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(36))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetInt64(a + flatbuffers.UOffsetT(j*8))
	}
	return 0
}

func (rcv *Tick) BidVolLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(36))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// 申买量
func (rcv *Tick) MutateBidVol(j int, n int64) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(36))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateInt64(a+flatbuffers.UOffsetT(j*8), n)
	}
	return false
}

/// 涨停价
func (rcv *Tick) UpperLimit() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(38))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// 涨停价
func (rcv *Tick) MutateUpperLimit(n float64) bool {
	return rcv._tab.MutateFloat64Slot(38, n)
}

/// 跌停价
func (rcv *Tick) LowerLimit() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(40))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// 跌停价
func (rcv *Tick) MutateLowerLimit(n float64) bool {
	return rcv._tab.MutateFloat64Slot(40, n)
}

/// 成交总量
func (rcv *Tick) Volume() uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(42))
	if o != 0 {
		return rcv._tab.GetUint64(o + rcv._tab.Pos)
	}
	return 0
}

/// 成交总量
func (rcv *Tick) MutateVolume(n uint64) bool {
	return rcv._tab.MutateUint64Slot(42, n)
}

/// 成交总金额
func (rcv *Tick) Amount() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(44))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// 成交总金额
func (rcv *Tick) MutateAmount(n float64) bool {
	return rcv._tab.MutateFloat64Slot(44, n)
}

/// IOPV(暂未提供)
/// 今结算，新增
func (rcv *Tick) SettlePx() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(46))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// IOPV(暂未提供)
/// 今结算，新增
func (rcv *Tick) MutateSettlePx(n float64) bool {
	return rcv._tab.MutateFloat64Slot(46, n)
}

/// 债券到期收益率(暂未提供)
/// 昨结算，新增
func (rcv *Tick) PreSettlePx() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(48))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// 债券到期收益率(暂未提供)
/// 昨结算，新增
func (rcv *Tick) MutatePreSettlePx(n float64) bool {
	return rcv._tab.MutateFloat64Slot(48, n)
}

/// 持仓量，新增
func (rcv *Tick) Interest() int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(50))
	if o != 0 {
		return rcv._tab.GetInt64(o + rcv._tab.Pos)
	}
	return 0
}

/// 持仓量，新增
func (rcv *Tick) MutateInterest(n int64) bool {
	return rcv._tab.MutateInt64Slot(50, n)
}

/// 昨持仓量，新增
func (rcv *Tick) PreInterest() int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(52))
	if o != 0 {
		return rcv._tab.GetInt64(o + rcv._tab.Pos)
	}
	return 0
}

/// 昨持仓量，新增
func (rcv *Tick) MutatePreInterest(n int64) bool {
	return rcv._tab.MutateInt64Slot(52, n)
}

/// 成交笔数///可卖空股数（美股行情用）
func (rcv *Tick) NumTrades() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(54))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

/// 成交笔数///可卖空股数（美股行情用）
func (rcv *Tick) MutateNumTrades(n int32) bool {
	return rcv._tab.MutateInt32Slot(54, n)
}

/// 委托买入总量///昨虚实度
func (rcv *Tick) TotalBidVol() int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(56))
	if o != 0 {
		return rcv._tab.GetInt64(o + rcv._tab.Pos)
	}
	return 0
}

/// 委托买入总量///昨虚实度
func (rcv *Tick) MutateTotalBidVol(n int64) bool {
	return rcv._tab.MutateInt64Slot(56, n)
}

/// 委托卖出总量///今虚实度
func (rcv *Tick) TotalAskVol() int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(58))
	if o != 0 {
		return rcv._tab.GetInt64(o + rcv._tab.Pos)
	}
	return 0
}

/// 委托卖出总量///今虚实度
func (rcv *Tick) MutateTotalAskVol(n int64) bool {
	return rcv._tab.MutateInt64Slot(58, n)
}

/// 加权平均委买价格(暂未提供)，新增
func (rcv *Tick) WeightedAvgBidPx() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(60))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// 加权平均委买价格(暂未提供)，新增
func (rcv *Tick) MutateWeightedAvgBidPx(n float64) bool {
	return rcv._tab.MutateFloat64Slot(60, n)
}

/// 加权平均委卖价格(暂未提供)，新增
func (rcv *Tick) WeightedAvgAskPx() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(62))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// 加权平均委卖价格(暂未提供)，新增
func (rcv *Tick) MutateWeightedAvgAskPx(n float64) bool {
	return rcv._tab.MutateFloat64Slot(62, n)
}

/// 本地接收时间(整数形式)，HHMMSSmmm 样例：93000500或者153000000
func (rcv *Tick) LocalTime() uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(64))
	if o != 0 {
		return rcv._tab.GetUint32(o + rcv._tab.Pos)
	}
	return 0
}

/// 本地接收时间(整数形式)，HHMMSSmmm 样例：93000500或者153000000
func (rcv *Tick) MutateLocalTime(n uint32) bool {
	return rcv._tab.MutateUint32Slot(64, n)
}

/// 交易所时间(整数形式)，HHMMSSmmm 样例：93000500或者153000000
func (rcv *Tick) ExchgTime() uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(66))
	if o != 0 {
		return rcv._tab.GetUint32(o + rcv._tab.Pos)
	}
	return 0
}

/// 交易所时间(整数形式)，HHMMSSmmm 样例：93000500或者153000000
func (rcv *Tick) MutateExchgTime(n uint32) bool {
	return rcv._tab.MutateUint32Slot(66, n)
}

/// 交易日，Epoch时间(13位数字，UTC时区)，样例：1676017139000
func (rcv *Tick) TradeDate() int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(68))
	if o != 0 {
		return rcv._tab.GetInt64(o + rcv._tab.Pos)
	}
	return 0
}

/// 交易日，Epoch时间(13位数字，UTC时区)，样例：1676017139000
func (rcv *Tick) MutateTradeDate(n int64) bool {
	return rcv._tab.MutateInt64Slot(68, n)
}

/// code_id的hash值，股票为code_id的数字，期货为code_id字符串的hash值
func (rcv *Tick) Key() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(70))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return -1
}

/// code_id的hash值，股票为code_id的数字，期货为code_id字符串的hash值
func (rcv *Tick) MutateKey(n int32) bool {
	return rcv._tab.MutateInt32Slot(70, n)
}

/// eam内码
func (rcv *Tick) EamCode() int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(72))
	if o != 0 {
		return rcv._tab.GetInt64(o + rcv._tab.Pos)
	}
	return 0
}

/// eam内码
func (rcv *Tick) MutateEamCode(n int64) bool {
	return rcv._tab.MutateInt64Slot(72, n)
}

func TickStart(builder *flatbuffers.Builder) {
	builder.StartObject(35)
}
func TickAddEpochLocalTime(builder *flatbuffers.Builder, epochLocalTime int64) {
	builder.PrependInt64Slot(0, epochLocalTime, 0)
}
func TickAddSymbol(builder *flatbuffers.Builder, symbol flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(symbol), 0)
}
func TickAddMarket(builder *flatbuffers.Builder, market flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(market), 0)
}
func TickAddStreamId(builder *flatbuffers.Builder, streamId uint32) {
	builder.PrependUint32Slot(3, streamId, 0)
}
func TickAddEpochExchgTime(builder *flatbuffers.Builder, epochExchgTime int64) {
	builder.PrependInt64Slot(4, epochExchgTime, 0)
}
func TickAddChannel(builder *flatbuffers.Builder, channel uint16) {
	builder.PrependUint16Slot(5, channel, 0)
}
func TickAddStatus(builder *flatbuffers.Builder, status int32) {
	builder.PrependInt32Slot(6, status, 0)
}
func TickAddPreClose(builder *flatbuffers.Builder, preClose float64) {
	builder.PrependFloat64Slot(7, preClose, 0.0)
}
func TickAddOpen(builder *flatbuffers.Builder, open float64) {
	builder.PrependFloat64Slot(8, open, 0.0)
}
func TickAddHigh(builder *flatbuffers.Builder, high float64) {
	builder.PrependFloat64Slot(9, high, 0.0)
}
func TickAddLow(builder *flatbuffers.Builder, low float64) {
	builder.PrependFloat64Slot(10, low, 0.0)
}
func TickAddMatch(builder *flatbuffers.Builder, match float64) {
	builder.PrependFloat64Slot(11, match, 0.0)
}
func TickAddClose(builder *flatbuffers.Builder, close float64) {
	builder.PrependFloat64Slot(12, close, 0.0)
}
func TickAddAskPx(builder *flatbuffers.Builder, askPx flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(13, flatbuffers.UOffsetT(askPx), 0)
}
func TickStartAskPxVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(8, numElems, 8)
}
func TickAddBidPx(builder *flatbuffers.Builder, bidPx flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(14, flatbuffers.UOffsetT(bidPx), 0)
}
func TickStartBidPxVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(8, numElems, 8)
}
func TickAddAskVol(builder *flatbuffers.Builder, askVol flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(15, flatbuffers.UOffsetT(askVol), 0)
}
func TickStartAskVolVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(8, numElems, 8)
}
func TickAddBidVol(builder *flatbuffers.Builder, bidVol flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(16, flatbuffers.UOffsetT(bidVol), 0)
}
func TickStartBidVolVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(8, numElems, 8)
}
func TickAddUpperLimit(builder *flatbuffers.Builder, upperLimit float64) {
	builder.PrependFloat64Slot(17, upperLimit, 0.0)
}
func TickAddLowerLimit(builder *flatbuffers.Builder, lowerLimit float64) {
	builder.PrependFloat64Slot(18, lowerLimit, 0.0)
}
func TickAddVolume(builder *flatbuffers.Builder, volume uint64) {
	builder.PrependUint64Slot(19, volume, 0)
}
func TickAddAmount(builder *flatbuffers.Builder, amount float64) {
	builder.PrependFloat64Slot(20, amount, 0.0)
}
func TickAddSettlePx(builder *flatbuffers.Builder, settlePx float64) {
	builder.PrependFloat64Slot(21, settlePx, 0.0)
}
func TickAddPreSettlePx(builder *flatbuffers.Builder, preSettlePx float64) {
	builder.PrependFloat64Slot(22, preSettlePx, 0.0)
}
func TickAddInterest(builder *flatbuffers.Builder, interest int64) {
	builder.PrependInt64Slot(23, interest, 0)
}
func TickAddPreInterest(builder *flatbuffers.Builder, preInterest int64) {
	builder.PrependInt64Slot(24, preInterest, 0)
}
func TickAddNumTrades(builder *flatbuffers.Builder, numTrades int32) {
	builder.PrependInt32Slot(25, numTrades, 0)
}
func TickAddTotalBidVol(builder *flatbuffers.Builder, totalBidVol int64) {
	builder.PrependInt64Slot(26, totalBidVol, 0)
}
func TickAddTotalAskVol(builder *flatbuffers.Builder, totalAskVol int64) {
	builder.PrependInt64Slot(27, totalAskVol, 0)
}
func TickAddWeightedAvgBidPx(builder *flatbuffers.Builder, weightedAvgBidPx float64) {
	builder.PrependFloat64Slot(28, weightedAvgBidPx, 0.0)
}
func TickAddWeightedAvgAskPx(builder *flatbuffers.Builder, weightedAvgAskPx float64) {
	builder.PrependFloat64Slot(29, weightedAvgAskPx, 0.0)
}
func TickAddLocalTime(builder *flatbuffers.Builder, localTime uint32) {
	builder.PrependUint32Slot(30, localTime, 0)
}
func TickAddExchgTime(builder *flatbuffers.Builder, exchgTime uint32) {
	builder.PrependUint32Slot(31, exchgTime, 0)
}
func TickAddTradeDate(builder *flatbuffers.Builder, tradeDate int64) {
	builder.PrependInt64Slot(32, tradeDate, 0)
}
func TickAddKey(builder *flatbuffers.Builder, key int32) {
	builder.PrependInt32Slot(33, key, -1)
}
func TickAddEamCode(builder *flatbuffers.Builder, eamCode int64) {
	builder.PrependInt64Slot(34, eamCode, 0)
}
func TickEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
